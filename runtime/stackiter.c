/*
 * Author:  Trevor Schiff, tschiff2020@my.fit.edu
 * Course:  CSE 4251, Section 01, Spring 2023
 * Project: MiniJava Compiler Project
 * Charset: US-ASCII
 */

#include "stackiter.h"
#include <assert.h>
#include <string.h>

// SP/FP contained in %o6/%i6
#define IO_REG_SP 6
#define IO_REG_FP IO_REG_SP

// Return address contained in %i7
#define IO_REG_RA 7

/**
 * @brief Symbols generated by the compiler to mark the range of MiniJava code
 * in the address space
 */
extern u8 __start_minijava[];
extern u8 __stop_minijava[];

/**
 * @brief Size of a stack frame with no locals
 */
static const u32 mjc_frame_size =
    sizeof(u32) * (1      // I think this was a hacky bug fix?
                   + 7    // Aggregate return value + callee arguments
                   + 16); // Register save

/**
 * @brief Retrieves the current stack pointer (SP)
 *
 * @details Forced to inline so that this function doesn't generate a stack
 * frame, even when compiling for debug builds
 */
__attribute__((always_inline)) static inline u32 get_sp(void) {
    u32 sp = 0;

    // Get value of SP
    asm("mov %%sp, %0" : "=r"(sp));
    return sp;
}

/**
 * @brief Discovers how many locals are in the stack frame
 *
 * @param it Stack frame iterator
 */
static void find_locals(StackIterator* it) {
    u32 curr;
    u32 prev;
    u32 local_size;

    assert(it != NULL);
    assert(it->window != NULL);

    // Get address of this frame and last frame
    curr = (u32)it->window;                   // SP
    prev = (u32)it->window->ioreg[IO_REG_FP]; // old SP (FP)
    // Stack grows downwards, newer frames should have lower addresses
    assert(curr < prev);

    // NULL FP = main function.
    // In MiniJava, the main function cannot have locals,
    // so it never has a stack frame.
    if (prev == 0) {
        it->locals = NULL;
        it->local_num = 0;
        return;
    }

    // Size of locals in this frame
    local_size = mjc_frame_size - (curr - prev);
    assert(local_size % sizeof(u32) == 0);

    // Every stack data type in MiniJava is 4 bytes
    it->local_num = local_size / sizeof(u32);

    // Locals are offset from the frame pointer (FP)
    it->locals = (u32*)prev;
}

/**
 * @brief Finds the first stack frame created by the MiniJava program
 *
 * @param it Stack frame iterator
 */
static void find_first_frame(StackIterator* it) {
    u32 ra;

    assert(it != NULL);

    // Get current stack frame (first iteration)
    it->window = (RegisterWindow*)get_sp();
    it->first = TRUE;

    // Ignore stack frames that are not from the MiniJava program
    while (stack_iterator_next(it) && it->window != NULL) {
        // Return address
        ra = it->window->ioreg[IO_REG_RA];

        // Return address in %i7 is actually minus 8.
        // I think this is because +4 for the CALL and +4 for the delay slot
        ra += 8;

        // Is the return address inside the MiniJava code?
        if (ra >= (u32)__start_minijava && ra < (u32)__stop_minijava) {
            // Begin future iteration from here
            return;
        }
    }

    // Hopefully we never see this!
    DEBUG_LOG("[stackiter] Could not find MiniJava stack frame!\n");
}

/**
 * @brief Initialize stack frame iterator structure
 *
 * @param it Stack frame iterator
 */
void stack_iterator_init(StackIterator* it) {
    assert(it != NULL);

    memset(it, 0, sizeof(StackIterator));
    it->first = FALSE;
}

/**
 * @brief Attempt to iterate to next (up) stack frame
 *
 * @param it Stack frame iterator
 * @return BOOL Success
 */
BOOL stack_iterator_next(StackIterator* it) {
    assert(it != NULL);

    // First iteration: grab current stack frame
    if (!it->first) {
        find_first_frame(it);
    }
    // Any other iteration: go up one frame
    else {
        // Stack pointer in %o6, therefore:
        // %o6 in this frame = previous SP
        if (it->window != NULL) {
            it->window = (RegisterWindow*)it->window->ioreg[IO_REG_FP];
        }
    }

    // Cannot go up
    if (it->window == NULL) {
        return FALSE;
    }

    // Check for locals
    find_locals(it);

    // Return whether future iteration is possible.
    // Iteration can continue when previous frame (frame pointer) is non-NULL.
    return it->window->ioreg[IO_REG_FP] != 0;
}
